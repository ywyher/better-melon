import { Dispatch, SetStateAction, useEffect, useState } from "react"
import { CardContent } from "@/components/ui/card"
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "@/components/ui/select"
import { Input } from "@/components/ui/input"
import { Switch } from "@/components/ui/switch"
import { useQuery, useQueryClient } from "@tanstack/react-query"
import { AnkiPreset } from "@/lib/db/schema"
import { FieldErrors, useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { Form, FormControl, FormField, FormItem, FormLabel, FormDescription } from "@/components/ui/form"
import { useIsSmall } from "@/lib/hooks/use-media-query"
import { toast } from "sonner"
import { X } from "lucide-react"
import { createPreset, updatePreset } from "@/app/settings/anki/actions"
import LoadingButton from "@/components/loading-button"
import { Button } from "@/components/ui/button"
import AnkiSkeleton from "@/app/settings/anki/_components/anki-skeleton"
import AnkiDeletePreset from "@/app/settings/anki/_components/anki-delete-preset"
import { ankiFieldsValues } from "@/lib/constants/anki"
import { userQueries } from "@/lib/queries/user"
import { ankiQueries } from "@/lib/queries/anki"

type PresetFormProps = {
    preset: AnkiPreset | null
    presets: AnkiPreset[];
    setSelectedPreset: Dispatch<SetStateAction<string>>
}

export const ankiPresetSchema = z.object({
    name: z.string().min(1, "Name is required"),
    deck: z.string().min(1, "Deck is required"),
    model: z.string().min(1, "Model is required"),
    fields: z.record(z.string(), z.string().optional()).optional(), // Object with field names as keys and optional values
    isDefault: z.boolean(),
    isGui: z.boolean()
})

export type AnkiPresetSchema = z.infer<typeof ankiPresetSchema>

export default function AnkiPresetForm({ 
    preset,
    presets,
    setSelectedPreset
}: PresetFormProps) {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [selectedModel, setSelectedModel] = useState<string>(preset?.model || "")

    const isSmall = useIsSmall()

    const queryClient = useQueryClient()
    const isFirstPreset = presets.length === 0

    const { data: deckNames, isLoading: isDeckNamesLoading } = useQuery({ ...ankiQueries.deckNames() })

    const { data: modelNames, isLoading: isModelNamesLoading } = useQuery({ ...ankiQueries.modelNames() })

    const { data: modelFieldNames } = useQuery({
        ...ankiQueries.modelFieldNames(selectedModel),
        enabled: !!selectedModel
    })

    const form = useForm<AnkiPresetSchema>({
        resolver: zodResolver(ankiPresetSchema),
        defaultValues: {
            name: preset?.name || "",
            deck: preset?.deck || "",
            model: preset?.model || "",
            fields: preset?.fields || {},
            isDefault: isFirstPreset ? true : preset?.isDefault || false,
            isGui: preset?.isGui || false,
        }
    })

    useEffect(() => {
        if (preset) {
          setSelectedModel(preset.model || "");
          
          form.reset({
            name: preset.name || "",
            deck: preset.deck || "",
            model: preset.model || "",
            fields: preset.fields || {},
            isDefault: isFirstPreset ? true : preset.isDefault || false,
            isGui: preset.isGui || false,
          });
        } else {
          setSelectedModel("");
          form.reset({
            name: "",
            deck: "",
            model: "",
            fields: {},
            isDefault: isFirstPreset ? true : false,
            isGui: false,
          });
        }
      }, [preset, form, isFirstPreset]);

    useEffect(() => {
        if (isFirstPreset) {
            form.setValue("isDefault", true);
        }
    }, [isFirstPreset, form]);

    // Update fields when model changes and field names are fetched
    useEffect(() => {
        if (modelFieldNames?.data && modelFieldNames.data.length > 0) {
            // Create a fields object from the existing preset fields or initialize new ones
            const fieldsObject = modelFieldNames.data.reduce((acc: Record<string, string | undefined>, fieldName: string) => {
                // Preserve existing values from preset or initialize to empty string
                acc[fieldName] = preset?.fields?.[fieldName] || "";
                return acc;
            }, {});
            
            // Update the form's fields value
            form.setValue("fields", fieldsObject);
        }
    }, [modelFieldNames?.data, preset?.fields, form]);

    const handleRemoveField = (fieldName: string) => {
        const currentFields = form.getValues().fields || {};
        const updatedFields = { ...currentFields };
        
        updatedFields[fieldName] = ""; 
        
        form.setValue("fields", updatedFields);
    };

    const onSubmit = async (data: AnkiPresetSchema) => {
        if(!data.fields || (Object.entries(data.fields).filter(([, value]) => value).length == 0)) {
            toast.error("At least one field need to be mapped")
            return;
        };
        setIsLoading(true)
        let result;
        if(preset) {
            result = await updatePreset({ data, id: preset.id })
        }else {
            result = await createPreset({ data })
        }

        if(result.error) {
            toast.error(result.error)
            setIsLoading(false)
            return;
        }

        const defaultPreset = presets.find(preset => preset.isDefault === true)
            
        queryClient.invalidateQueries({ queryKey: userQueries.session._def })
        queryClient.invalidateQueries({ queryKey: ankiQueries._def })
        setSelectedPreset(defaultPreset?.id || "new")
        toast.message(result.message)
        setIsLoading(false)
    }

    const onError = (errors: FieldErrors<AnkiPresetSchema>) => {
        const position = isSmall ? "top-center" : "bottom-right"
        const firstError = Object.values(errors)[0];
    
        if (firstError && 'message' in firstError && typeof firstError.message === 'string') {
            toast.error(firstError.message, { position });
        }
    }
    
    if (!deckNames || !modelNames || isDeckNamesLoading || isModelNamesLoading) {
        return <AnkiSkeleton />
    }

    return (
        <CardContent className="flex flex-col gap-4 py-3 px-6">
            <Form {...form}>
                <form className="flex flex-col space-y-6" onSubmit={form.handleSubmit(onSubmit, onError)}>
                    <div className="space-y-4">
                        <FormField
                            control={form.control}
                            name="name"
                            render={({ field }) => (
                                <FormItem className="grid grid-cols-8 items-center gap-4">
                                    <FormLabel className="col-span-3 text-sm font-medium">Preset Name</FormLabel>
                                    <FormControl>
                                        <Input 
                                            className="col-span-5 w-full" 
                                            placeholder="Enter preset name"
                                            {...field}
                                        />
                                    </FormControl>
                                </FormItem>
                            )}
                        />
                        <FormField
                            control={form.control}
                            name="deck"
                            render={({ field }) => (
                                <FormItem className="grid grid-cols-8 items-center gap-4">
                                    <FormLabel className="col-span-3 text-sm font-medium">Deck</FormLabel>
                                    <FormControl>
                                        <Select onValueChange={field.onChange} value={field.value}>
                                            <SelectTrigger className="col-span-5 w-full cursor-pointer">
                                                <SelectValue placeholder="Select deck" />
                                            </SelectTrigger>
                                            <SelectContent>
                                                {deckNames.data?.map((deck: string, idx: number) => (
                                                    <SelectItem key={idx} value={deck}>
                                                        {deck}
                                                    </SelectItem>
                                                ))}
                                            </SelectContent>
                                        </Select>
                                    </FormControl>
                                </FormItem>
                            )}
                        />
                        <FormField
                            control={form.control}
                            name="model"
                            render={({ field }) => (
                                <FormItem className="grid grid-cols-8 items-center gap-4">
                                    <FormLabel className="col-span-3 text-sm font-medium">Model</FormLabel>
                                    <FormControl>
                                        <Select 
                                            value={field.value} 
                                            onValueChange={(e) => {
                                                field.onChange(e)
                                                setSelectedModel(e)
                                            }}
                                        >
                                            <SelectTrigger className="col-span-5 w-full cursor-pointer">
                                                <SelectValue placeholder="Select model" />
                                            </SelectTrigger>
                                            <SelectContent>
                                                {modelNames.data?.map((model: string, idx: number) => (
                                                    <SelectItem key={idx} value={model}>
                                                        {model}
                                                    </SelectItem>
                                                ))}
                                            </SelectContent>
                                        </Select>
                                    </FormControl>
                                </FormItem>
                            )}
                        />
                    </div>
                    {modelFieldNames?.data && modelFieldNames.data.length > 0 && (
                        <div className="bg-muted/20 rounded-lg p-4 border border-border">
                            <h3 className="text-sm font-medium mb-4">Field Mappings</h3>
                            <div className="grid grid-cols-8 gap-4 mb-2 border-b pb-2">
                                <div className="col-span-3 font-medium text-sm text-muted-foreground">Anki Field</div>
                                <div className="col-span-5 font-medium text-sm text-muted-foreground">Maps To</div>
                            </div>
                            
                            <div className="space-y-3">
                                {modelFieldNames.data.map((fieldName: string) => (
                                    <div key={fieldName} className="grid grid-cols-8 gap-4 items-center">
                                        <div className="col-span-3 text-sm font-medium">{fieldName}</div>
                                        <div className="col-span-5 flex items-center gap-2">
                                            <FormField
                                                control={form.control}
                                                name={`fields.${fieldName}`}
                                                render={({ field }) => (
                                                    <FormItem className="flex-1">
                                                        <FormControl>
                                                            <div className="flex gap-2 items-center">
                                                                <Select 
                                                                    value={field.value || ""} 
                                                                    onValueChange={field.onChange}
                                                                >
                                                                    <SelectTrigger className="w-full cursor-pointer">
                                                                        <SelectValue placeholder="Select value" />
                                                                    </SelectTrigger>
                                                                    <SelectContent>
                                                                        {ankiFieldsValues.map((value) => (
                                                                            <SelectItem key={value} value={value}>
                                                                                &#123;{value}&#125;
                                                                            </SelectItem>
                                                                        ))}
                                                                    </SelectContent>
                                                                </Select>
                                                                {field.value && (
                                                                    <Button
                                                                        type="button" 
                                                                        variant="ghost" 
                                                                        size="icon" 
                                                                        className="h-8 w-8 text-muted-foreground hover:text-destructive"
                                                                        onClick={() => handleRemoveField(fieldName)}
                                                                    >
                                                                        <X size={16} />
                                                                    </Button>
                                                                )}
                                                            </div>
                                                        </FormControl>
                                                    </FormItem>
                                                )}
                                            />
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    <div className="space-y-3 pt-2">
                        <FormField
                            control={form.control}
                            name="isDefault"
                            render={({ field }) => (
                                <FormItem className="flex flex-row items-center justify-between rounded-lg border p-4">
                                    <div className="space-y-0.5">
                                        <FormLabel className="text-base">Default Preset</FormLabel>
                                        <FormDescription>
                                            Use this preset by default when creating new cards
                                        </FormDescription>
                                    </div>
                                    <FormControl>
                                        <Switch 
                                            className="cursor-pointer"
                                            checked={field.value}
                                            onCheckedChange={field.onChange}
                                            disabled={isFirstPreset}
                                        />
                                    </FormControl>
                                </FormItem>
                            )}
                        />
                        <FormField
                            control={form.control}
                            name="isGui"
                            render={({ field }) => (
                                <FormItem className="flex flex-row items-center justify-between rounded-lg border p-4">
                                    <div className="space-y-0.5">
                                        <FormLabel className="text-base">Show Anki GUI</FormLabel>
                                        <FormDescription>
                                            Show the Anki add card/note GUI instead of adding directly
                                        </FormDescription>
                                    </div>
                                    <FormControl>
                                        <Switch 
                                            className="cursor-pointer"
                                            checked={field.value}
                                            onCheckedChange={field.onChange}
                                        />
                                    </FormControl>
                                </FormItem>
                            )}
                        />
                    </div>
                    <LoadingButton isLoading={isLoading} className="w-full">
                        {preset ? "Update Preset" : "Create Preset"}
                    </LoadingButton>
                </form>
            </Form>
            {preset && (
                <AnkiDeletePreset
                    presets={presets}
                    presetId={preset.id}
                    setSelectedPreset={setSelectedPreset}
                />
            )}
        </CardContent>
    )
}


useful for domains shit:
https://regery.com/
https://receive-smss.com/

forget password doesnt work

If you're using Next.js you need to call router.refresh() after signing in to clear the router cache

prefetch funtioanlity is trying to refetch next episode on movies! !
also the delay doesnt get set for whatever reason !
also when not fullscreen you make the font smaller remove that since if we remove the panel its too small
styles controlers doesnt work too ?
add a button on the panel to take you to the current active cue

check out
1- https://github.com/shaka-project/shaka-player
2- https://github.com/zhw2590582/ArtPlayer

so when we log as anon we should invalidate the session query

ability to move the transcriptoins around freely through a handler on the top left or something

animekai as a provider

check the index>header file for an error with the dialog wrapper

mark a wodd as kniwn
custom styles foe known words
import known words to anki deck
maybe also other status for words like hard or easy
each with its custom styles

support for furigana

for is refetching add a loading overlay on the refetchinf thing
1- the subtitle styles component

we changed how displayValue works in the use-styles-controller maybe in the others too ?

what is .ssa, maybe will support it too ? check it out on death note ep 15 too

puase player on definition trigger or hover or click or none !!!!

sometimes the proxy fails -> maybe add a refetch or something in that case

later add a protips page or something to show tips like the ctrl + c copy the current cue text !!
or basically a hotkeys instructions when we add the rest (if there is)

begin where you left off > save where the user ended last time they watched a certain episode
prob not that important tho 
-> maybe the best way to implement this is to save watched episode an a history table and each video with its own how much the user have seen of it

add the ability to disable auto scroll to the current cue and the ability to customize the countdown when the user is scrolling before it returns to the current cue

update the skeletons for general settings and subtitle styles since you chagned the content

hide spoilers

watch or info page
> Choose whether to go to the info page or watch page when selecting an anime.

maybe on the info page if its an anime of 1 episodes just prefetch it right away

auto add to list

dialog z-index > toast z-index => bad UX 
i suppose it can be fixed using createPortal from react

use cache for session which are being fetched from the server ??

input validation/sanitization 

check turoborepo

check if memoizing subtitle cue solve the performance issue on vivaldi

implement caching for the mapper

episodes metadata for the episode selector

for schedules dont use anilist its based on japanese tv

preview subtitle for when the settings change (not important)